function [lossP, lossR, ...
          xTPprop, xTPpropH,xTPpropW, ...
          xTPprop2,xTPpropH2,xTPpropW2, ...
          gradientsE, gradientsD] = ...
                                    modelLoss(netE,netD, ...
                                              X,...
                                              tau,tauH,tauW, ...
                                              btype_label,label_height, ...
                                              ind,...
                                              gradientsE_prev,gradientsD_prev, ...
                                              trainBoolean)

    % Pre-process labels
    [   sub_label_roofwall, ...
        sub_label_height, ...
        indtemp, ...
        subtemp, subtempH, ...
        unique_subtemp,unique_subtempH, ...
        nsubtemp, nsubtempH] = ...
        preprocessLabels(btype_label, ...
                         label_height, ...
                         ind);


    % Forward through encoder & decoder
    subZ = forward(netE,X(:,indtemp)+1e-6);
    subY = forward(netD,subZ);

    % Encode clustering constraints
    [   constraints_array, ...
        constraints_array_H, ...
        constraints_array_W] = ...
        encodeConstraints(tau, tauH, tauW, ...
                          subtemp, subtempH, ...
                          nsubtemp, nsubtempH, ...
                          indtemp);

    % Perform clustering
    % optCluster = 1; %MinCostFlow
    [   labelsLocal, ...
        labelsLocalH, ...
        labelsLocalW, ...
        centroids, ...
        centroidsH, ...
        centroidsW ...
        ] = clusterLatent(  optCluster, ...
                            subZ, ...
                            constraints_array, ...
                            constraints_array_H, ...
                            constraints_array_W, ...
                            subtemp, ...
                            subtempH);

    % Compute prediction loss
    if trainBoolean == true
        [lossP] = ...
            computeLoss(...
                subZ, indtemp, ...
                constraints_array, ...
                constraints_array_H, ...
                constraints_array_W, ... 
                centroids, ...
                centroidsH, ...
                centroidsW, ...
                subtemp, subtempH, ...
                nsubtemp, nsubtempH, ...
                unique_subtemp, unique_subtempH);
    else
        lossP =  NaN;
    end

    % Compute reconstruction Loss
    if trainBoolean == true
        lossR = rmse(subY,X(:,indtemp)+1e-6,'all');
    else
        lossR =  NaN;
    end

    % Compute metrics
    [xTPprop,xTPpropH,xTPpropW,xTPprop2,xTPpropH2,xTPpropW2] = ...
        computeMetrics(...
            labelsLocal, ...
            labelsLocalH, ...
            labelsLocalW, ...
            constraints_array_H, constraints_array_W, ...
            subtemp, subtempH, ...
            nsubtemp, nsubtempH);

    % Compute Total Loss and Gradient Update
    if trainBoolean == true
        loss = (lossP + lossR);
        [gradientsE,gradientsD] = ...
            dlgradient(dlarray(loss,'BC'),netE.Learnables,netD.Learnables);
        if anynan(extractdata(gradientsE.Value{1,1})) || anynan(extractdata(gradientsD.Value{1,1}))
            disp('nan gradient explosion alert')
            gradientsE = gradientsE_prev;
            gradientsD = gradientsD_prev;
        end
    else
        gradientsE = NaN;
        gradientsD = NaN;
    end

end